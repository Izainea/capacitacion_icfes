<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lección 3.2: Controlando el Flujo con Conductores</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Teko:wght@400;600&display=swap" rel="stylesheet">

    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --primary-color: #ff9900; /* AWS Orange */
            --secondary-color: #232f3e; /* AWS Dark Blue */
            --text-color: #e0e0e0;
            --text-muted: #a0a0a0;
            --border-color: #333;
            --success-color: #28a745;
            --info-color: #5dade2;
            --danger-color: #e74c3c;
        }

        html { scroll-behavior: smooth; }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 40px 20px;
            text-align: center;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: auto;
        }

        h1, h2, h3, h4 {
            font-family: 'Teko', sans-serif;
            font-weight: 600;
            letter-spacing: 1px;
        }

        h1 {
            font-size: 4.5rem;
            color: var(--primary-color);
            margin-bottom: 0;
        }
        
        h2 {
            font-size: 3rem;
            color: var(--text-color);
            border-bottom: 2px solid var(--primary-color);
            display: inline-block;
            padding-bottom: 10px;
            margin-top: 80px;
        }

        .subtitle {
            font-size: 1.6rem;
            color: var(--text-muted);
            margin-top: 0;
            margin-bottom: 80px;
        }

        .section {
            margin-bottom: 100px;
        }

        p {
            font-size: 1.2rem;
            line-height: 1.7;
            color: var(--text-muted);
            max-width: 800px;
            margin: 20px auto 40px;
            text-align: left;
        }
        .center-p {
             text-align: center;
        }
        
        pre {
            background-color: #0d1117;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            text-align: left;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #c9d1d9;
        }
        
        .code-block-title {
            text-align: left;
            font-family: 'Roboto', sans-serif;
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: -10px;
            padding: 5px 15px;
            border-radius: 5px 5px 0 0;
            display: inline-block;
        }
        
        .code-problem {
            color: white;
            background-color: var(--danger-color);
        }
        
        .code-solution {
            color: var(--secondary-color);
            background-color: var(--success-color);
        }

        code {
            background-color: var(--secondary-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
        }
        
        .step-guide {
            text-align: left;
            max-width: 900px;
            margin: 40px auto;
        }
        .step {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        .step h3 {
            font-size: 2.2rem;
            color: var(--primary-color);
            margin-top: 0;
        }
        
        .navigation-section {
            background: var(--secondary-color); padding: 60px 30px; border-radius: 15px; margin-top: 80px;
        }
        .navigation-section h2 { border: none; }
        .nav-buttons {
            display: flex; justify-content: center; gap: 20px; margin-top: 30px; flex-wrap: wrap;
        }
        .nav-button {
            padding: 15px 30px; border: none; border-radius: 50px; font-size: 1.2rem; font-weight: bold; text-decoration: none;
            transition: transform 0.3s, box-shadow 0.3s; display: inline-flex; align-items: center; gap: 10px; cursor: pointer;
        }
        .back-button {
            background-color: var(--card-bg); color: var(--primary-color); border: 2px solid var(--primary-color);
        }
        .next-button {
            background-color: var(--primary-color); color: var(--secondary-color);
        }
        .next-button.disabled {
            background-color: var(--border-color); color: var(--text-muted); cursor: not-allowed;
        }
        .nav-button:hover:not(.disabled) {
            transform: scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

    </style>
</head>
<body>

    <div class="container">

        <header>
            <h1>Controlando el Flujo con Conductores</h1>
            <p class="subtitle center-p">Las herramientas para optimizar, controlar y ejecutar acciones en tu app.</p>
        </header>

        <main>
            <section class="section" id="introduccion">
                <h2>Más Allá de la Reacción Automática</h2>
                <p>
                    En la lección anterior, aprendimos que Shiny reacciona automáticamente a los cambios en los inputs. Esto es fantástico para la interactividad simple, pero en aplicaciones del mundo real, a menudo necesitamos más control. ¿Qué pasa si un cálculo es muy lento y no queremos que se ejecute con cada pequeño ajuste? ¿O si queremos realizar una acción, como guardar un archivo, sin necesidad de producir un output visible?
                </p>
                <p>
                    Aquí es donde entran en juego los <strong>conductores reactivos</strong>. Son las herramientas que nos permiten pasar de una reactividad simple y automática a un flujo de trabajo controlado, eficiente y profesional. Nos dan el poder de decidir <em>cuándo</em> y <em>cómo</em> se ejecuta nuestro código.
                </p>
            </section>
            
            <section class="section" id="conductores">
                <h2>Explorando los Conductores Reactivos</h2>
                <p class="center-p">Los conductores son tus herramientas más poderosas para orquestar el flujo reactivo. Hay tres principales que cubren casi todas las necesidades.</p>
                <div class="step-guide">
                    <div class="step" style="border-left: 4px solid var(--success-color);">
                        <h3><code>reactive({ ... })</code>: El Trabajador Eficiente</h3>
                        <p><strong>¿Qué hace?</strong> Crea una expresión reactiva que actúa como un "componente intermedio". Calcula un valor y lo guarda en caché. Este cálculo solo se re-ejecuta si las fuentes reactivas de las que depende cambian. Si múltiples outputs piden su valor, pero nada ha cambiado, devuelve el resultado guardado sin volver a calcular. Para acceder a su resultado, siempre debes llamarlo como una función (ej., <code>datos_filtrados()</code>).</p>
                        <p><strong>Cuándo usarlo:</strong> Es tu herramienta principal para evitar la duplicación de código (principio DRY). Úsalo siempre que un mismo cálculo (filtrar datos, ajustar un modelo simple) sea necesario para más de un output. Garantiza que el trabajo se haga una sola vez.</p>
                    </div>
                    <div class="step" style="border-left: 4px solid var(--info-color);">
                        <h3><code>eventReactive({ ... })</code>: El Trabajador Obediente</h3>
                        <p><strong>¿Qué hace?</strong> Es similar a <code>reactive()</code>, pero con una diferencia crucial: solo se re-ejecuta cuando una <strong>fuente reactiva específica que tú designas</strong> (típicamente un <code>actionButton</code>) es activada. Ignora los cambios en otras dependencias hasta que recibe la "señal" explícita para actuar.</p>
                        <p><strong>Cuándo usarlo:</strong> Para procesos computacionalmente costosos o que no deben ejecutarse constantemente. Si tienes 10 sliders para configurar un modelo, no quieres que el modelo se re-entrene con cada mínimo movimiento. En su lugar, usas <code>eventReactive()</code> para que solo se ejecute cuando el usuario haga clic en un botón de "Analizar" o "Calcular".</p>
                    </div>
                    <div class="step" style="border-left: 4px solid var(--danger-color);">
                        <h3><code>observeEvent({ ... })</code>: El Mensajero</h3>
                        <p><strong>¿Qué hace?</strong> A diferencia de los otros dos, este conductor no devuelve un valor para ser usado en otro lugar. Su único propósito es realizar una <strong>acción</strong> o "efecto secundario" cuando un evento ocurre. No produce un output, simplemente "hace algo".</p>
                        <p><strong>Cuándo usarlo:</strong> Para tareas que no actualizan un gráfico o una tabla, como mostrar una notificación emergente (<code>showNotification()</code>), guardar datos en un archivo, imprimir mensajes de depuración en la consola (<code>cat()</code>), o actualizar dinámicamente los valores de otro control de input (<code>updateSelectInput()</code>).</p>
                    </div>
                </div>
            </section>
            
            <section class="section" id="taller">
                <h2>Taller Práctico: Implementando Control en Nuestra App</h2>
                <p class="center-p">Vamos a refactorizar nuestra aplicación de análisis del ICFES para que el usuario tenga el control total sobre cuándo se ejecuta el análisis.</p>
                <div class="step-guide">
                    <div class="step">
                        <h3>Paso 1: Añadir un Botón de Acción a la UI</h3>
                        <p>Primero, necesitamos el "gatillo" que iniciará el análisis. Abre el archivo de tu UI (<code>ui.R</code> o la sección `ui` de tu `app.R`) y añade un <code>actionButton</code> dentro del <code>sidebarPanel</code>, justo debajo de los selectores.</p>
                        <pre><code># ... dentro del sidebarPanel ...
      selectInput(
        inputId = "var_y",
        label = "Seleccione Puntaje Eje Y:",
        choices = puntajes_choices,
        selected = "punt_lectura_critica"
      ),
      
      # NUEVO BOTÓN
      actionButton(
        inputId = "run_analysis", 
        label = "Ejecutar Análisis", 
        icon = icon("play"),
        class = "btn-success" # Estilo de Bootstrap para un botón verde
      )
# ...
</code></pre>
                    </div>
                    <div class="step">
                        <h3>Paso 2: Usar <code>eventReactive</code> para Controlar el Cálculo</h3>
                        <p>Ahora, en tu lógica de servidor (<code>server.R</code> o la función `server`), reemplaza el <code>reactive()</code> que tenías por un <code>eventReactive()</code>. El primer argumento de esta función es el input que lo activa (nuestro botón), y el segundo es el bloque de código que se ejecutará.</p>
                        <pre><code># Reemplaza tu conductor reactivo anterior con este:

# Este conductor ahora SÓLO se ejecutará cuando se presione input$run_analysis
datos_analisis <- eventReactive(input$run_analysis, {
  
  # Filtramos los datos usando los valores actuales de los selectores
  datos_saber %>%
    filter(cole_naturaleza == input$naturaleza_select)
})

# Asegúrate de que tus outputs ahora usen el nuevo conductor: datos_analisis()
output$scatter_plot <- renderPlotly({
  p <- ggplot(datos_analisis(), aes_string(x = input$var_x, y = input$var_y)) +
    # ... resto del código del gráfico ...
  ggplotly(p)
})

output$tabla_completa <- renderDataTable({
  datos_analisis()
})
</code></pre>
                    </div>
                    <div class="step">
                        <h3>Paso 3: Dar Feedback al Usuario con <code>observeEvent</code></h3>
                        <p>Para mejorar la experiencia, podemos notificar al usuario que el análisis ha comenzado. Usaremos un <code>observeEvent</code> que "escuche" al mismo botón y muestre un mensaje.</p>
                        <p>Añade este bloque de código en cualquier parte dentro de tu función `server`.</p>
                        <pre><code># Este observador se dispara cuando se hace clic en el botón
observeEvent(input$run_analysis, {
  
  # Muestra una notificación temporal en la esquina de la app
  showNotification("Generando análisis...", type = "message")
  
  # También podemos imprimir en la consola para depuración
  cat("Análisis iniciado a las:", format(Sys.time()), "\n")
})
</code></pre>
                        <p>¡Vuelve a ejecutar tu aplicación! Ahora notarás que puedes cambiar los selectores libremente, y el gráfico y la tabla solo se actualizarán cuando hagas clic en "Ejecutar Análisis", momento en el cual también aparecerá una notificación. ¡Has tomado el control total del flujo reactivo!</p>
                    </div>
                     <div class="step">
                        <h3>Paso 4: Versionar los Cambios</h3>
                        <p>Has implementado una mejora fundamental en la funcionalidad y eficiencia de la aplicación. Es hora de guardarlo en Git.</p>
                        <pre><code># Añade los cambios en los archivos ui.R y server.R (o app.R)
git add .

# Crea un commit descriptivo
git commit -m "feat(analysis): Implementa control de ejecución con eventReactive y notificaciones"

# Sube los cambios a GitHub
git push
</code></pre>
                    </div>
                </div>
            </section>
            
            <!-- NUEVA SECCIÓN DE ERRORES COMUNES -->
            <section class="section" id="errores-comunes">
                <h2><i class="fa-solid fa-lightbulb"></i> Apéndice: Desmitificando Errores Comunes</h2>
                <p class="center-p">Entender estos errores es un paso clave para dominar el flujo de datos en tus aplicaciones. Veamos dos casos prácticos que ilustran conceptos fundamentales de la reactividad.</p>
                
                <div class="step-guide">
                    <div class="step">
                        <h3>Error 1: El Bucle Infinito (Recursión Accidental)</h3>
                        <p>Este es uno de los errores conceptuales más comunes. Ocurre cuando un conductor reactivo intenta usarse a sí mismo como fuente de datos, creando un ciclo que Shiny no puede resolver.</p>
                        
                        <span class="code-block-title code-problem">Código Problemático</span>
                        <pre><code># Se intenta crear un reactive que se llama a sí mismo
datos_saber_muestra <- reactive({
  if (input$naturaleza_colegio == "Todos") {
    # PROBLEMA: ¡Está intentando devolver su propio resultado!
    return(datos_saber_muestra) 
  } else {
    # PROBLEMA: ¡Está intentando filtrar su propio resultado!
    return(datos_saber_muestra %>% filter(cole_naturaleza == input$naturaleza_colegio))
  }
})</code></pre>
                        <p><strong>La causa:</strong> El conductor `datos_saber_muestra` se está llamando a sí mismo dentro de su propia definición. Es como decir: "Para definir X, primero necesito el valor de X".</p>
                        
                        <span class="code-block-title code-solution">Código Corregido</span>
                        <pre><code># El conductor ahora parte del dataframe original "datos_saber"
datos_filtrados <- eventReactive(input$run_analysis, {
  # Usamos el dataframe original como fuente
  df <- datos_saber 
  
  if (input$naturaleza_colegio == "Todos") {
    return(df)
  } else {
    return(df %>% filter(cole_naturaleza == input$naturaleza_colegio))
  }
})</code></pre>
                         <p><strong>La solución:</strong> Un conductor reactivo siempre debe partir de una fuente no reactiva (como el `datos_saber` original) o de *otro* conductor reactivo ya definido.</p>
                    </div>

                    <div class="step">
                        <h3>Error 2: El "Contexto Reactivo" Perdido</h3>
                        <p>Este error ilustra la regla más importante de Shiny: <strong>solo puedes usar un valor reactivo (ej. `datos_filtrados()`) dentro de un contexto reactivo (ej. `renderText`, `observeEvent`).</strong></p>

                        <span class="code-block-title code-problem">Código Problemático</span>
                        <pre><code># 1. Se intenta llamar a un reactive FUERA de un contexto reactivo
total_estudiantes_kpi <- format(nrow(datos_filtrados())) 

# 2. El renderText tiene una sintaxis incorrecta
output$total_estudiantes_kpi <- renderText({
  total_estudiantes_kpi,  # Esto no funciona como se espera
  big.mark = "," 
})</code></pre>
                        <p><strong>La causa:</strong> El código fuera de un `render...` o `observe...` se ejecuta solo una vez al inicio. No puedes llamar a `datos_filtrados()` ahí porque su valor depende de interacciones del usuario que aún no han ocurrido.</p>
                        
                        <span class="code-block-title code-solution">Código Corregido</span>
                        <pre><code># La lógica completa se mueve DENTRO del renderText
output$total_estudiantes_kpi <- renderText({
  
  # 1. Llama al reactive para obtener el dataframe filtrado
  df_filtrado <- datos_filtrados()
  
  # 2. Calcula y formatea el resultado en un solo paso
  total <- nrow(df_filtrado)
  
  # 3. La función devuelve el valor final formateado
  format(total, big.mark = ",")
})</code></pre>
                        <p><strong>La solución:</strong> Toda la lógica que dependa de un valor reactivo debe estar contenida **dentro** de un bloque de código reactivo. Así, Shiny sabe que debe re-ejecutar ese bloque cuando el valor reactivo del que depende cambie.</p>
                    </div>
                </div>
            </section>
            
            <section class="section navigation-section">
                <h2>¿Qué Sigue?</h2>
                <p class="center-p">Ya dominas el "cuándo" y el "cómo" de la ejecución de código. El siguiente paso es organizar ese código de manera profesional para que tus proyectos puedan crecer sin convertirse en un caos.</p>
                <div class="nav-buttons">
                    <a href="reactividad_core.html" class="nav-button back-button"><i class="fa-solid fa-arrow-left"></i> Lección 3.1: Reactividad</a>
                    <a href="arquitectura_modularizacion.html" class="nav-button next-button">Siguiente: Arquitectura y Modularización <i class="fa-solid fa-arrow-right"></i></a>
                </div>
            </section>
        </main>
    </div>

</body>
</html>
